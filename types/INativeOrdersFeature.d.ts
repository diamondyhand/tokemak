/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
  ethers,
  EventFilter,
  Signer,
  BigNumber,
  BigNumberish,
  PopulatedTransaction,
  BaseContract,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  CallOverrides,
} from "ethers";
import { BytesLike } from "@ethersproject/bytes";
import { Listener, Provider } from "@ethersproject/providers";
import { FunctionFragment, EventFragment, Result } from "@ethersproject/abi";
import type { TypedEventFilter, TypedEvent, TypedListener } from "./common";

interface INativeOrdersFeatureInterface extends ethers.utils.Interface {
  functions: {
    "_fillLimitOrder((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32),uint128,address,address)": FunctionFragment;
    "_fillRfqOrder((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32),uint128,address,bool,address)": FunctionFragment;
    "batchCancelLimitOrders(tuple[])": FunctionFragment;
    "batchCancelPairLimitOrders(address[],address[],uint256[])": FunctionFragment;
    "batchCancelPairLimitOrdersWithSigner(address,address[],address[],uint256[])": FunctionFragment;
    "batchCancelPairRfqOrders(address[],address[],uint256[])": FunctionFragment;
    "batchCancelPairRfqOrdersWithSigner(address,address[],address[],uint256[])": FunctionFragment;
    "batchCancelRfqOrders(tuple[])": FunctionFragment;
    "batchGetLimitOrderRelevantStates(tuple[],tuple[])": FunctionFragment;
    "batchGetRfqOrderRelevantStates(tuple[],tuple[])": FunctionFragment;
    "cancelLimitOrder((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256))": FunctionFragment;
    "cancelPairLimitOrders(address,address,uint256)": FunctionFragment;
    "cancelPairLimitOrdersWithSigner(address,address,address,uint256)": FunctionFragment;
    "cancelPairRfqOrders(address,address,uint256)": FunctionFragment;
    "cancelPairRfqOrdersWithSigner(address,address,address,uint256)": FunctionFragment;
    "cancelRfqOrder((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256))": FunctionFragment;
    "fillLimitOrder((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32),uint128)": FunctionFragment;
    "fillOrKillLimitOrder((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32),uint128)": FunctionFragment;
    "fillOrKillRfqOrder((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32),uint128)": FunctionFragment;
    "fillRfqOrder((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32),uint128)": FunctionFragment;
    "getLimitOrderHash((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256))": FunctionFragment;
    "getLimitOrderInfo((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256))": FunctionFragment;
    "getLimitOrderRelevantState((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32))": FunctionFragment;
    "getProtocolFeeMultiplier()": FunctionFragment;
    "getRfqOrderHash((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256))": FunctionFragment;
    "getRfqOrderInfo((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256))": FunctionFragment;
    "getRfqOrderRelevantState((address,address,uint128,uint128,address,address,address,bytes32,uint64,uint256),(uint8,uint8,bytes32,bytes32))": FunctionFragment;
    "isValidOrderSigner(address,address)": FunctionFragment;
    "registerAllowedOrderSigner(address,bool)": FunctionFragment;
    "registerAllowedRfqOrigins(address[],bool)": FunctionFragment;
    "transferProtocolFeesForPools(bytes32[])": FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: "_fillLimitOrder",
    values: [
      {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      BigNumberish,
      string,
      string
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "_fillRfqOrder",
    values: [
      {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      BigNumberish,
      string,
      boolean,
      string
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "batchCancelLimitOrders",
    values: [
      {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "batchCancelPairLimitOrders",
    values: [string[], string[], BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "batchCancelPairLimitOrdersWithSigner",
    values: [string, string[], string[], BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "batchCancelPairRfqOrders",
    values: [string[], string[], BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "batchCancelPairRfqOrdersWithSigner",
    values: [string, string[], string[], BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "batchCancelRfqOrders",
    values: [
      {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "batchGetLimitOrderRelevantStates",
    values: [
      {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "batchGetRfqOrderRelevantStates",
    values: [
      {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelLimitOrder",
    values: [
      {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelPairLimitOrders",
    values: [string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelPairLimitOrdersWithSigner",
    values: [string, string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelPairRfqOrders",
    values: [string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelPairRfqOrdersWithSigner",
    values: [string, string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelRfqOrder",
    values: [
      {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fillLimitOrder",
    values: [
      {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fillOrKillLimitOrder",
    values: [
      {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fillOrKillRfqOrder",
    values: [
      {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fillRfqOrder",
    values: [
      {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getLimitOrderHash",
    values: [
      {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getLimitOrderInfo",
    values: [
      {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getLimitOrderRelevantState",
    values: [
      {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getProtocolFeeMultiplier",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getRfqOrderHash",
    values: [
      {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getRfqOrderInfo",
    values: [
      {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getRfqOrderRelevantState",
    values: [
      {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "isValidOrderSigner",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "registerAllowedOrderSigner",
    values: [string, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "registerAllowedRfqOrigins",
    values: [string[], boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "transferProtocolFeesForPools",
    values: [BytesLike[]]
  ): string;

  decodeFunctionResult(
    functionFragment: "_fillLimitOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "_fillRfqOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchCancelLimitOrders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchCancelPairLimitOrders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchCancelPairLimitOrdersWithSigner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchCancelPairRfqOrders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchCancelPairRfqOrdersWithSigner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchCancelRfqOrders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchGetLimitOrderRelevantStates",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchGetRfqOrderRelevantStates",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelLimitOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelPairLimitOrders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelPairLimitOrdersWithSigner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelPairRfqOrders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelPairRfqOrdersWithSigner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelRfqOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fillLimitOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fillOrKillLimitOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fillOrKillRfqOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fillRfqOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getLimitOrderHash",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getLimitOrderInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getLimitOrderRelevantState",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getProtocolFeeMultiplier",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getRfqOrderHash",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getRfqOrderInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getRfqOrderRelevantState",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isValidOrderSigner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "registerAllowedOrderSigner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "registerAllowedRfqOrigins",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferProtocolFeesForPools",
    data: BytesLike
  ): Result;

  events: {
    "LimitOrderFilled(bytes32,address,address,address,address,address,uint128,uint128,uint128,uint256,bytes32)": EventFragment;
    "OrderCancelled(bytes32,address)": EventFragment;
    "OrderSignerRegistered(address,address,bool)": EventFragment;
    "PairCancelledLimitOrders(address,address,address,uint256)": EventFragment;
    "PairCancelledRfqOrders(address,address,address,uint256)": EventFragment;
    "RfqOrderFilled(bytes32,address,address,address,address,uint128,uint128,bytes32)": EventFragment;
    "RfqOrderOriginsAllowed(address,address[],bool)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "LimitOrderFilled"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OrderCancelled"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OrderSignerRegistered"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "PairCancelledLimitOrders"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "PairCancelledRfqOrders"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RfqOrderFilled"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RfqOrderOriginsAllowed"): EventFragment;
}

export type LimitOrderFilledEvent = TypedEvent<
  [
    string,
    string,
    string,
    string,
    string,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    string
  ] & {
    orderHash: string;
    maker: string;
    taker: string;
    feeRecipient: string;
    makerToken: string;
    takerToken: string;
    takerTokenFilledAmount: BigNumber;
    makerTokenFilledAmount: BigNumber;
    takerTokenFeeFilledAmount: BigNumber;
    protocolFeePaid: BigNumber;
    pool: string;
  }
>;

export type OrderCancelledEvent = TypedEvent<
  [string, string] & { orderHash: string; maker: string }
>;

export type OrderSignerRegisteredEvent = TypedEvent<
  [string, string, boolean] & {
    maker: string;
    signer: string;
    allowed: boolean;
  }
>;

export type PairCancelledLimitOrdersEvent = TypedEvent<
  [string, string, string, BigNumber] & {
    maker: string;
    makerToken: string;
    takerToken: string;
    minValidSalt: BigNumber;
  }
>;

export type PairCancelledRfqOrdersEvent = TypedEvent<
  [string, string, string, BigNumber] & {
    maker: string;
    makerToken: string;
    takerToken: string;
    minValidSalt: BigNumber;
  }
>;

export type RfqOrderFilledEvent = TypedEvent<
  [string, string, string, string, string, BigNumber, BigNumber, string] & {
    orderHash: string;
    maker: string;
    taker: string;
    makerToken: string;
    takerToken: string;
    takerTokenFilledAmount: BigNumber;
    makerTokenFilledAmount: BigNumber;
    pool: string;
  }
>;

export type RfqOrderOriginsAllowedEvent = TypedEvent<
  [string, string[], boolean] & {
    origin: string;
    addrs: string[];
    allowed: boolean;
  }
>;

export class INativeOrdersFeature extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  listeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter?: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): Array<TypedListener<EventArgsArray, EventArgsObject>>;
  off<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  on<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  once<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeListener<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeAllListeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): this;

  listeners(eventName?: string): Array<Listener>;
  off(eventName: string, listener: Listener): this;
  on(eventName: string, listener: Listener): this;
  once(eventName: string, listener: Listener): this;
  removeListener(eventName: string, listener: Listener): this;
  removeAllListeners(eventName?: string): this;

  queryFilter<EventArgsArray extends Array<any>, EventArgsObject>(
    event: TypedEventFilter<EventArgsArray, EventArgsObject>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEvent<EventArgsArray & EventArgsObject>>>;

  interface: INativeOrdersFeatureInterface;

  functions: {
    _fillLimitOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      taker: string,
      sender: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    _fillRfqOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      taker: string,
      useSelfBalance: boolean,
      recipient: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    batchCancelLimitOrders(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    batchCancelPairLimitOrders(
      makerTokens: string[],
      takerTokens: string[],
      minValidSalts: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    batchCancelPairLimitOrdersWithSigner(
      maker: string,
      makerTokens: string[],
      takerTokens: string[],
      minValidSalts: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    batchCancelPairRfqOrders(
      makerTokens: string[],
      takerTokens: string[],
      minValidSalts: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    batchCancelPairRfqOrdersWithSigner(
      maker: string,
      makerTokens: string[],
      takerTokens: string[],
      minValidSalts: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    batchCancelRfqOrders(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    batchGetLimitOrderRelevantStates(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      signatures: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[],
      overrides?: CallOverrides
    ): Promise<
      [
        ([string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        })[],
        BigNumber[],
        boolean[]
      ] & {
        orderInfos: ([string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        })[];
        actualFillableTakerTokenAmounts: BigNumber[];
        isSignatureValids: boolean[];
      }
    >;

    batchGetRfqOrderRelevantStates(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      signatures: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[],
      overrides?: CallOverrides
    ): Promise<
      [
        ([string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        })[],
        BigNumber[],
        boolean[]
      ] & {
        orderInfos: ([string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        })[];
        actualFillableTakerTokenAmounts: BigNumber[];
        isSignatureValids: boolean[];
      }
    >;

    cancelLimitOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    cancelPairLimitOrders(
      makerToken: string,
      takerToken: string,
      minValidSalt: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    cancelPairLimitOrdersWithSigner(
      maker: string,
      makerToken: string,
      takerToken: string,
      minValidSalt: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    cancelPairRfqOrders(
      makerToken: string,
      takerToken: string,
      minValidSalt: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    cancelPairRfqOrdersWithSigner(
      maker: string,
      makerToken: string,
      takerToken: string,
      minValidSalt: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    cancelRfqOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    fillLimitOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    fillOrKillLimitOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    fillOrKillRfqOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    fillRfqOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    getLimitOrderHash(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<[string] & { orderHash: string }>;

    getLimitOrderInfo(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<
      [
        [string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        }
      ] & {
        orderInfo: [string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        };
      }
    >;

    getLimitOrderRelevantState(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<
      [
        [string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        },
        BigNumber,
        boolean
      ] & {
        orderInfo: [string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        };
        actualFillableTakerTokenAmount: BigNumber;
        isSignatureValid: boolean;
      }
    >;

    getProtocolFeeMultiplier(
      overrides?: CallOverrides
    ): Promise<[number] & { multiplier: number }>;

    getRfqOrderHash(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<[string] & { orderHash: string }>;

    getRfqOrderInfo(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<
      [
        [string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        }
      ] & {
        orderInfo: [string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        };
      }
    >;

    getRfqOrderRelevantState(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<
      [
        [string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        },
        BigNumber,
        boolean
      ] & {
        orderInfo: [string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        };
        actualFillableTakerTokenAmount: BigNumber;
        isSignatureValid: boolean;
      }
    >;

    isValidOrderSigner(
      maker: string,
      signer: string,
      overrides?: CallOverrides
    ): Promise<[boolean] & { isAllowed: boolean }>;

    registerAllowedOrderSigner(
      signer: string,
      allowed: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    registerAllowedRfqOrigins(
      origins: string[],
      allowed: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    transferProtocolFeesForPools(
      poolIds: BytesLike[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  };

  _fillLimitOrder(
    order: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      takerTokenFeeAmount: BigNumberish;
      maker: string;
      taker: string;
      sender: string;
      feeRecipient: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    },
    signature: {
      signatureType: BigNumberish;
      v: BigNumberish;
      r: BytesLike;
      s: BytesLike;
    },
    takerTokenFillAmount: BigNumberish,
    taker: string,
    sender: string,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  _fillRfqOrder(
    order: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      maker: string;
      taker: string;
      txOrigin: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    },
    signature: {
      signatureType: BigNumberish;
      v: BigNumberish;
      r: BytesLike;
      s: BytesLike;
    },
    takerTokenFillAmount: BigNumberish,
    taker: string,
    useSelfBalance: boolean,
    recipient: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  batchCancelLimitOrders(
    orders: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      takerTokenFeeAmount: BigNumberish;
      maker: string;
      taker: string;
      sender: string;
      feeRecipient: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    }[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  batchCancelPairLimitOrders(
    makerTokens: string[],
    takerTokens: string[],
    minValidSalts: BigNumberish[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  batchCancelPairLimitOrdersWithSigner(
    maker: string,
    makerTokens: string[],
    takerTokens: string[],
    minValidSalts: BigNumberish[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  batchCancelPairRfqOrders(
    makerTokens: string[],
    takerTokens: string[],
    minValidSalts: BigNumberish[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  batchCancelPairRfqOrdersWithSigner(
    maker: string,
    makerTokens: string[],
    takerTokens: string[],
    minValidSalts: BigNumberish[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  batchCancelRfqOrders(
    orders: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      maker: string;
      taker: string;
      txOrigin: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    }[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  batchGetLimitOrderRelevantStates(
    orders: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      takerTokenFeeAmount: BigNumberish;
      maker: string;
      taker: string;
      sender: string;
      feeRecipient: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    }[],
    signatures: {
      signatureType: BigNumberish;
      v: BigNumberish;
      r: BytesLike;
      s: BytesLike;
    }[],
    overrides?: CallOverrides
  ): Promise<
    [
      ([string, number, BigNumber] & {
        orderHash: string;
        status: number;
        takerTokenFilledAmount: BigNumber;
      })[],
      BigNumber[],
      boolean[]
    ] & {
      orderInfos: ([string, number, BigNumber] & {
        orderHash: string;
        status: number;
        takerTokenFilledAmount: BigNumber;
      })[];
      actualFillableTakerTokenAmounts: BigNumber[];
      isSignatureValids: boolean[];
    }
  >;

  batchGetRfqOrderRelevantStates(
    orders: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      maker: string;
      taker: string;
      txOrigin: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    }[],
    signatures: {
      signatureType: BigNumberish;
      v: BigNumberish;
      r: BytesLike;
      s: BytesLike;
    }[],
    overrides?: CallOverrides
  ): Promise<
    [
      ([string, number, BigNumber] & {
        orderHash: string;
        status: number;
        takerTokenFilledAmount: BigNumber;
      })[],
      BigNumber[],
      boolean[]
    ] & {
      orderInfos: ([string, number, BigNumber] & {
        orderHash: string;
        status: number;
        takerTokenFilledAmount: BigNumber;
      })[];
      actualFillableTakerTokenAmounts: BigNumber[];
      isSignatureValids: boolean[];
    }
  >;

  cancelLimitOrder(
    order: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      takerTokenFeeAmount: BigNumberish;
      maker: string;
      taker: string;
      sender: string;
      feeRecipient: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    },
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  cancelPairLimitOrders(
    makerToken: string,
    takerToken: string,
    minValidSalt: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  cancelPairLimitOrdersWithSigner(
    maker: string,
    makerToken: string,
    takerToken: string,
    minValidSalt: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  cancelPairRfqOrders(
    makerToken: string,
    takerToken: string,
    minValidSalt: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  cancelPairRfqOrdersWithSigner(
    maker: string,
    makerToken: string,
    takerToken: string,
    minValidSalt: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  cancelRfqOrder(
    order: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      maker: string;
      taker: string;
      txOrigin: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    },
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  fillLimitOrder(
    order: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      takerTokenFeeAmount: BigNumberish;
      maker: string;
      taker: string;
      sender: string;
      feeRecipient: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    },
    signature: {
      signatureType: BigNumberish;
      v: BigNumberish;
      r: BytesLike;
      s: BytesLike;
    },
    takerTokenFillAmount: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  fillOrKillLimitOrder(
    order: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      takerTokenFeeAmount: BigNumberish;
      maker: string;
      taker: string;
      sender: string;
      feeRecipient: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    },
    signature: {
      signatureType: BigNumberish;
      v: BigNumberish;
      r: BytesLike;
      s: BytesLike;
    },
    takerTokenFillAmount: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  fillOrKillRfqOrder(
    order: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      maker: string;
      taker: string;
      txOrigin: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    },
    signature: {
      signatureType: BigNumberish;
      v: BigNumberish;
      r: BytesLike;
      s: BytesLike;
    },
    takerTokenFillAmount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  fillRfqOrder(
    order: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      maker: string;
      taker: string;
      txOrigin: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    },
    signature: {
      signatureType: BigNumberish;
      v: BigNumberish;
      r: BytesLike;
      s: BytesLike;
    },
    takerTokenFillAmount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  getLimitOrderHash(
    order: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      takerTokenFeeAmount: BigNumberish;
      maker: string;
      taker: string;
      sender: string;
      feeRecipient: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    },
    overrides?: CallOverrides
  ): Promise<string>;

  getLimitOrderInfo(
    order: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      takerTokenFeeAmount: BigNumberish;
      maker: string;
      taker: string;
      sender: string;
      feeRecipient: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    },
    overrides?: CallOverrides
  ): Promise<
    [string, number, BigNumber] & {
      orderHash: string;
      status: number;
      takerTokenFilledAmount: BigNumber;
    }
  >;

  getLimitOrderRelevantState(
    order: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      takerTokenFeeAmount: BigNumberish;
      maker: string;
      taker: string;
      sender: string;
      feeRecipient: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    },
    signature: {
      signatureType: BigNumberish;
      v: BigNumberish;
      r: BytesLike;
      s: BytesLike;
    },
    overrides?: CallOverrides
  ): Promise<
    [
      [string, number, BigNumber] & {
        orderHash: string;
        status: number;
        takerTokenFilledAmount: BigNumber;
      },
      BigNumber,
      boolean
    ] & {
      orderInfo: [string, number, BigNumber] & {
        orderHash: string;
        status: number;
        takerTokenFilledAmount: BigNumber;
      };
      actualFillableTakerTokenAmount: BigNumber;
      isSignatureValid: boolean;
    }
  >;

  getProtocolFeeMultiplier(overrides?: CallOverrides): Promise<number>;

  getRfqOrderHash(
    order: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      maker: string;
      taker: string;
      txOrigin: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    },
    overrides?: CallOverrides
  ): Promise<string>;

  getRfqOrderInfo(
    order: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      maker: string;
      taker: string;
      txOrigin: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    },
    overrides?: CallOverrides
  ): Promise<
    [string, number, BigNumber] & {
      orderHash: string;
      status: number;
      takerTokenFilledAmount: BigNumber;
    }
  >;

  getRfqOrderRelevantState(
    order: {
      makerToken: string;
      takerToken: string;
      makerAmount: BigNumberish;
      takerAmount: BigNumberish;
      maker: string;
      taker: string;
      txOrigin: string;
      pool: BytesLike;
      expiry: BigNumberish;
      salt: BigNumberish;
    },
    signature: {
      signatureType: BigNumberish;
      v: BigNumberish;
      r: BytesLike;
      s: BytesLike;
    },
    overrides?: CallOverrides
  ): Promise<
    [
      [string, number, BigNumber] & {
        orderHash: string;
        status: number;
        takerTokenFilledAmount: BigNumber;
      },
      BigNumber,
      boolean
    ] & {
      orderInfo: [string, number, BigNumber] & {
        orderHash: string;
        status: number;
        takerTokenFilledAmount: BigNumber;
      };
      actualFillableTakerTokenAmount: BigNumber;
      isSignatureValid: boolean;
    }
  >;

  isValidOrderSigner(
    maker: string,
    signer: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  registerAllowedOrderSigner(
    signer: string,
    allowed: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  registerAllowedRfqOrigins(
    origins: string[],
    allowed: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  transferProtocolFeesForPools(
    poolIds: BytesLike[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    _fillLimitOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      taker: string,
      sender: string,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        takerTokenFilledAmount: BigNumber;
        makerTokenFilledAmount: BigNumber;
      }
    >;

    _fillRfqOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      taker: string,
      useSelfBalance: boolean,
      recipient: string,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        takerTokenFilledAmount: BigNumber;
        makerTokenFilledAmount: BigNumber;
      }
    >;

    batchCancelLimitOrders(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      overrides?: CallOverrides
    ): Promise<void>;

    batchCancelPairLimitOrders(
      makerTokens: string[],
      takerTokens: string[],
      minValidSalts: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<void>;

    batchCancelPairLimitOrdersWithSigner(
      maker: string,
      makerTokens: string[],
      takerTokens: string[],
      minValidSalts: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<void>;

    batchCancelPairRfqOrders(
      makerTokens: string[],
      takerTokens: string[],
      minValidSalts: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<void>;

    batchCancelPairRfqOrdersWithSigner(
      maker: string,
      makerTokens: string[],
      takerTokens: string[],
      minValidSalts: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<void>;

    batchCancelRfqOrders(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      overrides?: CallOverrides
    ): Promise<void>;

    batchGetLimitOrderRelevantStates(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      signatures: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[],
      overrides?: CallOverrides
    ): Promise<
      [
        ([string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        })[],
        BigNumber[],
        boolean[]
      ] & {
        orderInfos: ([string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        })[];
        actualFillableTakerTokenAmounts: BigNumber[];
        isSignatureValids: boolean[];
      }
    >;

    batchGetRfqOrderRelevantStates(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      signatures: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[],
      overrides?: CallOverrides
    ): Promise<
      [
        ([string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        })[],
        BigNumber[],
        boolean[]
      ] & {
        orderInfos: ([string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        })[];
        actualFillableTakerTokenAmounts: BigNumber[];
        isSignatureValids: boolean[];
      }
    >;

    cancelLimitOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<void>;

    cancelPairLimitOrders(
      makerToken: string,
      takerToken: string,
      minValidSalt: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    cancelPairLimitOrdersWithSigner(
      maker: string,
      makerToken: string,
      takerToken: string,
      minValidSalt: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    cancelPairRfqOrders(
      makerToken: string,
      takerToken: string,
      minValidSalt: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    cancelPairRfqOrdersWithSigner(
      maker: string,
      makerToken: string,
      takerToken: string,
      minValidSalt: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    cancelRfqOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<void>;

    fillLimitOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        takerTokenFilledAmount: BigNumber;
        makerTokenFilledAmount: BigNumber;
      }
    >;

    fillOrKillLimitOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fillOrKillRfqOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fillRfqOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        takerTokenFilledAmount: BigNumber;
        makerTokenFilledAmount: BigNumber;
      }
    >;

    getLimitOrderHash(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<string>;

    getLimitOrderInfo(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<
      [string, number, BigNumber] & {
        orderHash: string;
        status: number;
        takerTokenFilledAmount: BigNumber;
      }
    >;

    getLimitOrderRelevantState(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<
      [
        [string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        },
        BigNumber,
        boolean
      ] & {
        orderInfo: [string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        };
        actualFillableTakerTokenAmount: BigNumber;
        isSignatureValid: boolean;
      }
    >;

    getProtocolFeeMultiplier(overrides?: CallOverrides): Promise<number>;

    getRfqOrderHash(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<string>;

    getRfqOrderInfo(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<
      [string, number, BigNumber] & {
        orderHash: string;
        status: number;
        takerTokenFilledAmount: BigNumber;
      }
    >;

    getRfqOrderRelevantState(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<
      [
        [string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        },
        BigNumber,
        boolean
      ] & {
        orderInfo: [string, number, BigNumber] & {
          orderHash: string;
          status: number;
          takerTokenFilledAmount: BigNumber;
        };
        actualFillableTakerTokenAmount: BigNumber;
        isSignatureValid: boolean;
      }
    >;

    isValidOrderSigner(
      maker: string,
      signer: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    registerAllowedOrderSigner(
      signer: string,
      allowed: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    registerAllowedRfqOrigins(
      origins: string[],
      allowed: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    transferProtocolFeesForPools(
      poolIds: BytesLike[],
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "LimitOrderFilled(bytes32,address,address,address,address,address,uint128,uint128,uint128,uint256,bytes32)"(
      orderHash?: null,
      maker?: null,
      taker?: null,
      feeRecipient?: null,
      makerToken?: null,
      takerToken?: null,
      takerTokenFilledAmount?: null,
      makerTokenFilledAmount?: null,
      takerTokenFeeFilledAmount?: null,
      protocolFeePaid?: null,
      pool?: null
    ): TypedEventFilter<
      [
        string,
        string,
        string,
        string,
        string,
        string,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        string
      ],
      {
        orderHash: string;
        maker: string;
        taker: string;
        feeRecipient: string;
        makerToken: string;
        takerToken: string;
        takerTokenFilledAmount: BigNumber;
        makerTokenFilledAmount: BigNumber;
        takerTokenFeeFilledAmount: BigNumber;
        protocolFeePaid: BigNumber;
        pool: string;
      }
    >;

    LimitOrderFilled(
      orderHash?: null,
      maker?: null,
      taker?: null,
      feeRecipient?: null,
      makerToken?: null,
      takerToken?: null,
      takerTokenFilledAmount?: null,
      makerTokenFilledAmount?: null,
      takerTokenFeeFilledAmount?: null,
      protocolFeePaid?: null,
      pool?: null
    ): TypedEventFilter<
      [
        string,
        string,
        string,
        string,
        string,
        string,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        string
      ],
      {
        orderHash: string;
        maker: string;
        taker: string;
        feeRecipient: string;
        makerToken: string;
        takerToken: string;
        takerTokenFilledAmount: BigNumber;
        makerTokenFilledAmount: BigNumber;
        takerTokenFeeFilledAmount: BigNumber;
        protocolFeePaid: BigNumber;
        pool: string;
      }
    >;

    "OrderCancelled(bytes32,address)"(
      orderHash?: null,
      maker?: null
    ): TypedEventFilter<[string, string], { orderHash: string; maker: string }>;

    OrderCancelled(
      orderHash?: null,
      maker?: null
    ): TypedEventFilter<[string, string], { orderHash: string; maker: string }>;

    "OrderSignerRegistered(address,address,bool)"(
      maker?: null,
      signer?: null,
      allowed?: null
    ): TypedEventFilter<
      [string, string, boolean],
      { maker: string; signer: string; allowed: boolean }
    >;

    OrderSignerRegistered(
      maker?: null,
      signer?: null,
      allowed?: null
    ): TypedEventFilter<
      [string, string, boolean],
      { maker: string; signer: string; allowed: boolean }
    >;

    "PairCancelledLimitOrders(address,address,address,uint256)"(
      maker?: null,
      makerToken?: null,
      takerToken?: null,
      minValidSalt?: null
    ): TypedEventFilter<
      [string, string, string, BigNumber],
      {
        maker: string;
        makerToken: string;
        takerToken: string;
        minValidSalt: BigNumber;
      }
    >;

    PairCancelledLimitOrders(
      maker?: null,
      makerToken?: null,
      takerToken?: null,
      minValidSalt?: null
    ): TypedEventFilter<
      [string, string, string, BigNumber],
      {
        maker: string;
        makerToken: string;
        takerToken: string;
        minValidSalt: BigNumber;
      }
    >;

    "PairCancelledRfqOrders(address,address,address,uint256)"(
      maker?: null,
      makerToken?: null,
      takerToken?: null,
      minValidSalt?: null
    ): TypedEventFilter<
      [string, string, string, BigNumber],
      {
        maker: string;
        makerToken: string;
        takerToken: string;
        minValidSalt: BigNumber;
      }
    >;

    PairCancelledRfqOrders(
      maker?: null,
      makerToken?: null,
      takerToken?: null,
      minValidSalt?: null
    ): TypedEventFilter<
      [string, string, string, BigNumber],
      {
        maker: string;
        makerToken: string;
        takerToken: string;
        minValidSalt: BigNumber;
      }
    >;

    "RfqOrderFilled(bytes32,address,address,address,address,uint128,uint128,bytes32)"(
      orderHash?: null,
      maker?: null,
      taker?: null,
      makerToken?: null,
      takerToken?: null,
      takerTokenFilledAmount?: null,
      makerTokenFilledAmount?: null,
      pool?: null
    ): TypedEventFilter<
      [string, string, string, string, string, BigNumber, BigNumber, string],
      {
        orderHash: string;
        maker: string;
        taker: string;
        makerToken: string;
        takerToken: string;
        takerTokenFilledAmount: BigNumber;
        makerTokenFilledAmount: BigNumber;
        pool: string;
      }
    >;

    RfqOrderFilled(
      orderHash?: null,
      maker?: null,
      taker?: null,
      makerToken?: null,
      takerToken?: null,
      takerTokenFilledAmount?: null,
      makerTokenFilledAmount?: null,
      pool?: null
    ): TypedEventFilter<
      [string, string, string, string, string, BigNumber, BigNumber, string],
      {
        orderHash: string;
        maker: string;
        taker: string;
        makerToken: string;
        takerToken: string;
        takerTokenFilledAmount: BigNumber;
        makerTokenFilledAmount: BigNumber;
        pool: string;
      }
    >;

    "RfqOrderOriginsAllowed(address,address[],bool)"(
      origin?: null,
      addrs?: null,
      allowed?: null
    ): TypedEventFilter<
      [string, string[], boolean],
      { origin: string; addrs: string[]; allowed: boolean }
    >;

    RfqOrderOriginsAllowed(
      origin?: null,
      addrs?: null,
      allowed?: null
    ): TypedEventFilter<
      [string, string[], boolean],
      { origin: string; addrs: string[]; allowed: boolean }
    >;
  };

  estimateGas: {
    _fillLimitOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      taker: string,
      sender: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    _fillRfqOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      taker: string,
      useSelfBalance: boolean,
      recipient: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    batchCancelLimitOrders(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    batchCancelPairLimitOrders(
      makerTokens: string[],
      takerTokens: string[],
      minValidSalts: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    batchCancelPairLimitOrdersWithSigner(
      maker: string,
      makerTokens: string[],
      takerTokens: string[],
      minValidSalts: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    batchCancelPairRfqOrders(
      makerTokens: string[],
      takerTokens: string[],
      minValidSalts: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    batchCancelPairRfqOrdersWithSigner(
      maker: string,
      makerTokens: string[],
      takerTokens: string[],
      minValidSalts: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    batchCancelRfqOrders(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    batchGetLimitOrderRelevantStates(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      signatures: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    batchGetRfqOrderRelevantStates(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      signatures: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    cancelLimitOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    cancelPairLimitOrders(
      makerToken: string,
      takerToken: string,
      minValidSalt: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    cancelPairLimitOrdersWithSigner(
      maker: string,
      makerToken: string,
      takerToken: string,
      minValidSalt: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    cancelPairRfqOrders(
      makerToken: string,
      takerToken: string,
      minValidSalt: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    cancelPairRfqOrdersWithSigner(
      maker: string,
      makerToken: string,
      takerToken: string,
      minValidSalt: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    cancelRfqOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    fillLimitOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    fillOrKillLimitOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    fillOrKillRfqOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    fillRfqOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    getLimitOrderHash(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getLimitOrderInfo(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getLimitOrderRelevantState(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getProtocolFeeMultiplier(overrides?: CallOverrides): Promise<BigNumber>;

    getRfqOrderHash(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getRfqOrderInfo(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getRfqOrderRelevantState(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isValidOrderSigner(
      maker: string,
      signer: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    registerAllowedOrderSigner(
      signer: string,
      allowed: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    registerAllowedRfqOrigins(
      origins: string[],
      allowed: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    transferProtocolFeesForPools(
      poolIds: BytesLike[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    _fillLimitOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      taker: string,
      sender: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    _fillRfqOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      taker: string,
      useSelfBalance: boolean,
      recipient: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    batchCancelLimitOrders(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    batchCancelPairLimitOrders(
      makerTokens: string[],
      takerTokens: string[],
      minValidSalts: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    batchCancelPairLimitOrdersWithSigner(
      maker: string,
      makerTokens: string[],
      takerTokens: string[],
      minValidSalts: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    batchCancelPairRfqOrders(
      makerTokens: string[],
      takerTokens: string[],
      minValidSalts: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    batchCancelPairRfqOrdersWithSigner(
      maker: string,
      makerTokens: string[],
      takerTokens: string[],
      minValidSalts: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    batchCancelRfqOrders(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    batchGetLimitOrderRelevantStates(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      signatures: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    batchGetRfqOrderRelevantStates(
      orders: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      }[],
      signatures: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      }[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    cancelLimitOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    cancelPairLimitOrders(
      makerToken: string,
      takerToken: string,
      minValidSalt: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    cancelPairLimitOrdersWithSigner(
      maker: string,
      makerToken: string,
      takerToken: string,
      minValidSalt: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    cancelPairRfqOrders(
      makerToken: string,
      takerToken: string,
      minValidSalt: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    cancelPairRfqOrdersWithSigner(
      maker: string,
      makerToken: string,
      takerToken: string,
      minValidSalt: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    cancelRfqOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    fillLimitOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    fillOrKillLimitOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    fillOrKillRfqOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    fillRfqOrder(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      takerTokenFillAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    getLimitOrderHash(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getLimitOrderInfo(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getLimitOrderRelevantState(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        takerTokenFeeAmount: BigNumberish;
        maker: string;
        taker: string;
        sender: string;
        feeRecipient: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getProtocolFeeMultiplier(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getRfqOrderHash(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getRfqOrderInfo(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getRfqOrderRelevantState(
      order: {
        makerToken: string;
        takerToken: string;
        makerAmount: BigNumberish;
        takerAmount: BigNumberish;
        maker: string;
        taker: string;
        txOrigin: string;
        pool: BytesLike;
        expiry: BigNumberish;
        salt: BigNumberish;
      },
      signature: {
        signatureType: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isValidOrderSigner(
      maker: string,
      signer: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    registerAllowedOrderSigner(
      signer: string,
      allowed: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    registerAllowedRfqOrigins(
      origins: string[],
      allowed: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    transferProtocolFeesForPools(
      poolIds: BytesLike[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;
  };
}
